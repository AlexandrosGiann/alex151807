<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ρεαλιστικό Ολογραφικό Μυρμήγκι</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #2d1b4e 100%);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
        .info {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            color: #ff6b35; font-size: 32px; font-weight: bold;
            text-shadow: 0 0 20px rgba(255,107,53,0.8), 0 0 40px rgba(255,107,53,0.5);
            z-index: 10; text-align: center; letter-spacing: 2px;
        }
        .controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: #ffffff; background: rgba(0,0,0,0.5); padding: 15px 25px;
            border-radius: 15px; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,107,53,0.3); z-index: 10; text-align: center; font-size: 14px;
        }
        #particles { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: rgba(30, 30, 40, 0.95);
            border: 2px solid #ff6b35;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            padding: 25px;
            color: white;
            position: relative;
            box-shadow: 0 0 40px rgba(255, 107, 53, 0.4);
            backdrop-filter: blur(10px);
        }
        
        .modal-header {
            color: #ff6b35;
            font-size: 24px;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.7);
        }
        
        .modal-body {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: justify;
        }
        
        .modal-close {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: block;
            margin: 0 auto;
            transition: all 0.3s;
        }
        
        .modal-close:hover {
            background: #ff4500;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.7);
        }
    </style>
</head>
<body>
    <div class="info">ΜΥΡΜΗΓΚΙ</div>
    <div class="controls">Σύρετε για περιστροφή | Scroll για zoom | Κάντε κλικ σε μέρη του μυρμηγκιού</div>
    <canvas id="particles"></canvas>
    <div id="canvas-container"></div>
    
    <!-- Modal Structure -->
    <div id="part-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title" class="modal-header">Τίτλος</h2>
            <p id="modal-description" class="modal-body">Περιγραφή...</p>
            <button id="modal-close" class="modal-close">Κλείσιμο</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Particle background
        const particleCanvas = document.getElementById('particles');
        const ctx = particleCanvas.getContext('2d');
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
        const particles = [];
        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * particleCanvas.width,
                y: Math.random() * particleCanvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 2
            });
        }
        function animateParticles() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
            ctx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy;
                if (p.x < 0 || p.x > particleCanvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > particleCanvas.height) p.vy *= -1;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6b35';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff6b35';
                ctx.fill();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        // Three.js Scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;
        scene.add(mainLight);
        const pointLight1 = new THREE.PointLight(0xff6b35, 1.5, 100);
        pointLight1.position.set(8, 5, 8);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xff4500, 1, 100);
        pointLight2.position.set(-8, 3, 8);
        scene.add(pointLight2);

        // Ground
        const groundGeo = new THREE.PlaneGeometry(20, 20);
        const groundMat = new THREE.ShadowMaterial({ opacity: 0.3 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Materials
        const headMaterial = new THREE.MeshPhongMaterial({ color: 0xd94a1a, emissive: 0x3a0a00, shininess: 80, transparent: true, opacity: 0.9 });
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b35, emissive: 0x4a1500, shininess: 60, transparent: true, opacity: 0.9 });
        const legMaterial = new THREE.MeshPhongMaterial({ color: 0xc94000, emissive: 0x2a0800, shininess: 40, transparent: true, opacity: 0.85 });
        const wireMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa66, wireframe: true, transparent: true, opacity: 0.15 });

        const antGroup = new THREE.Group();

        // THORAX
        const thoraxGroup = new THREE.Group();
        thoraxGroup.position.set(0, 0.05, 0);

        const thorax1Geo = new THREE.SphereGeometry(0.3, 16, 16);
        const thorax1 = new THREE.Mesh(thorax1Geo, bodyMaterial);
        const thorax1Wire = new THREE.Mesh(thorax1Geo, wireMaterial);
        thorax1.scale.set(0.9, 0.8, 1);
        thorax1Wire.scale.set(0.9, 0.8, 1);
        thorax1.position.set(0, 0, 0.3);
        thorax1Wire.position.set(0, 0, 0.3);
        thorax1.castShadow = true;
        // Προσθήκη userData για αναγνώριση
        thorax1.userData = { part: 'thorax', name: 'Θώρακας', description: 'Ο θώρακας είναι το μεσαίο τμήμα του σώματος του μυρμηγκιού, στο οποίο προσαρτώνται τα πόδια και οι πτέρυγες (στα ενηλίκα αρσενικά και θηλυκά). Συνδεδεμένα γονίδια: Si-CSP10, Si-OBP14' };
        thoraxGroup.add(thorax1, thorax1Wire);

        const thorax2Geo = new THREE.SphereGeometry(0.28, 16, 16);
        const thorax2 = new THREE.Mesh(thorax2Geo, bodyMaterial);
        const thorax2Wire = new THREE.Mesh(thorax2Geo, wireMaterial);
        thorax2.scale.set(0.85, 0.75,0.9);
        thorax2Wire.scale.set(0.85,0.75,0.9);
        thorax2.position.set(0,-0.05,-0.2);
        thorax2Wire.position.set(0,-0.05,-0.2);
        thorax2.castShadow = true;
        thorax2.userData = { part: 'thorax2', name: 'Μεσοθώρακας', description: 'Το μεσαίο τμήμα του θώρακα που συνδέεται με την κοιλιά.' };
        thoraxGroup.add(thorax2, thorax2Wire);

        // HEAD
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 0.05, 0.55);
        const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const head = new THREE.Mesh(headGeo, headMaterial);
        const headWire = new THREE.Mesh(headGeo, wireMaterial);
        head.scale.set(1, 0.9, 1.1);
        headWire.scale.set(1, 0.9, 1.1);
        head.position.set(0, 0, 0.3);
        headWire.position.set(0, 0, 0.3);
        head.castShadow = true;
        head.userData = { part: 'head', name: 'Κεφάλι', description: 'Το κεφάλι του μυρμηγκιού περιέχει τα μάτια, τις κεραίες και τα δυνατά σαγόνια (μαντιβύλες). Συνδεδεμένα γονίδια: Gp-9, Si-OBP15' };
        headGroup.add(head, headWire);
        
// MANDIBLES (two semicircles with teeth) — rotated 90° and pushed inside
const mandiblesGroup = new THREE.Group();

// (1) Πιο μέσα στο κεφάλι: χαμήλωσα λίγο το z (προς τα πίσω) και ελάχιστα το y
mandiblesGroup.position.set(0, -0.06, 0.56);

// (2) Περιστροφή 90°: από “κύκλο στο X-Y” σε “κύκλο στο X-Z”
mandiblesGroup.rotation.x = Math.PI / 2;

headGroup.add(mandiblesGroup);

const ringR = 0.30;      // ακτίνα
const tubeR = 0.060;     // πάχος μαντιβύλας
const gapA  = 0.16;      // κενό στο “σπάσιμο” του κύκλου

const toothCount = 10;
const toothH = 0.10;
const toothR = 0.022;

function buildSemiMandible(thetaStart, thetaEnd, userData) {
  const mat = legMaterial.clone();

  // Arc στο τοπικό επίπεδο X-Y (μετά το group rotation θα γίνει X-Z)
  const arc2 = new THREE.EllipseCurve(
    0, 0,
    ringR, ringR,
    thetaStart, thetaEnd,
    false,
    0
  );

  const pts2 = arc2.getPoints(80);
  const pts3 = pts2.map(p => new THREE.Vector3(p.x, p.y, 0));

  const path = new THREE.CatmullRomCurve3(pts3, false, "centripetal", 0.5);

  const mandibleGeo = new THREE.TubeGeometry(path, 180, tubeR, 16, false);
  const mandibleMesh = new THREE.Mesh(mandibleGeo, mat);
  mandibleMesh.castShadow = true;
  mandibleMesh.userData = userData;
  mandiblesGroup.add(mandibleMesh);

  // Teeth: προς το κέντρο, και “μισοθαμμένα” στο σωλήνα
  const toothGeo = new THREE.ConeGeometry(toothR, toothH, 12);
  const up = new THREE.Vector3(0, 1, 0);

  for (let i = 0; i < toothCount; i++) {
    const t = (i + 1) / (toothCount + 1);

    const p = path.getPoint(t);
    const inward = p.clone().multiplyScalar(-1).normalize(); // προς το (0,0,0)

    // Σημείο κόλλησης κοντά στην εσωτερική επιφάνεια
    const attach = p.clone().addScaledVector(inward, tubeR * 0.90);

    const tooth = new THREE.Mesh(toothGeo, mat);
    tooth.quaternion.setFromUnitVectors(up, inward);

    // “Μισό μέσα”: αν το έβαζα toothH/2 θα ήταν πολύ έξω
    tooth.position.copy(attach).addScaledVector(inward, toothH * 0.35);

    tooth.castShadow = true;
    tooth.userData = userData;
    mandiblesGroup.add(tooth);
  }
}

// Δεξί “)” (x >= 0)
buildSemiMandible(
  -Math.PI / 2 + gapA,
   Math.PI / 2 - gapA,
  {
    part: "mandible",
    name: "Μαντιβύλα (Αριστερή)",
    description: "Ημικυκλικό σαγόνι με δόντια."
  }
);

// Αριστερό “(” (x <= 0)
buildSemiMandible(
   Math.PI / 2 + gapA,
   3 * Math.PI / 2 - gapA,
  {
    part: "mandible2",
    name: "Μαντιβύλα (Δεξιά)",
    description: "Ημικυκλικό σαγόνι με δόντια."
  }
);

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000, emissive: 0x330000, shininess: 100 });
        const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
        eye1.position.set(0.25, 0.15, 0.20);
        eye1.userData = { part: 'eye', name: 'Μάτι (Αριστερό)', description: 'Τα μάτια του μυρμηγκιού είναι σύνθετα και αποτελούνται από πολλές μικρές οφθαλμίδες, που του επιτρέπουν να ανιχνεύει κίνηση.' };
        headGroup.add(eye1);
        const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
        eye2.position.set(-0.25, 0.15, 0.20);
        eye2.userData = { part: 'eye2', name: 'Μάτι (Δεξί)', description: 'Τα μάτια του μυρμηγκιού είναι σύνθετα και αποτελούνται από πολλές μικρές οφθαλμίδες, που του επιτρέπουν να ανιχνεύει κίνηση.' };
        headGroup.add(eye2);

        thoraxGroup.add(headGroup);

        // ANTENNAE - FIXED VERSION (TURNED FORWARD)
        const antennaSegments = [];
        [-1, 1].forEach(side => {
            const antennaBase = new THREE.Group();
            antennaBase.position.set(side * 0.15, 0.25, 0.4);
            
            // ΜΟΝΟ ΑΥΤΗ Η ΑΛΛΑΓΗ: από -Math.PI/4 σε Math.PI/4 (90 μοίρες περιστροφή)
            antennaBase.rotation.x = Math.PI / 6;
            antennaBase.rotation.y = side * Math.PI / 3;
            
            const scapeGeo = new THREE.CylinderGeometry(0.03, 0.025, 0.25, 8);
            const scape = new THREE.Mesh(scapeGeo, legMaterial);
            const scapePivot = new THREE.Group();
            scape.position.set(0, 0.125, 0);
            scapePivot.rotation.x = Math.PI / 3;
            scapePivot.rotation.z = side * Math.PI / 3;
            scape.userData = { part: 'antenna', name: 'Κεραία', description: 'Οι κεραίες είναι τα κύρια αισθητήρια όργανα του μυρμηγκιού, χρησιμοποιούνται για την αφή, τη μυρωδιά και την επικοινωνία. Συνδεδεμένα γονίδια: Si-CSP1, Si-OBP5' };
            scapePivot.add(scape);
            antennaBase.add(scapePivot);

            const seg1Geo = new THREE.CylinderGeometry(0.02, 0.02, 0.22, 8);
            const seg1 = new THREE.Mesh(seg1Geo, legMaterial);
            const seg1Pivot = new THREE.Group();
            seg1.position.set(0, 0.11, 0);
            seg1Pivot.position.set(0, 0.25, 0);
            seg1Pivot.rotation.x = Math.PI / 8;
            seg1Pivot.add(seg1);
            scapePivot.add(seg1Pivot);

            const seg2Geo = new THREE.CylinderGeometry(0.018, 0.018, 0.2, 8);
            const seg2 = new THREE.Mesh(seg2Geo, legMaterial);
            const seg2Pivot = new THREE.Group();
            seg2.position.set(0, 0.1, 0);
            seg2Pivot.position.set(0, 0.22, 0);
            seg2Pivot.rotation.x = Math.PI / 10;
            seg2Pivot.add(seg2);
            seg1Pivot.add(seg2Pivot);

            antennaSegments.push({ scapePivot, seg1Pivot, seg2Pivot, side });
            headGroup.add(antennaBase);
        });

        // ABDOMEN
        const petioleGeo = new THREE.CylinderGeometry(0.08,0.1,0.3,8);
        const petiole = new THREE.Mesh(petioleGeo, legMaterial);
        petiole.position.set(0,-0.02,-0.45);
        petiole.rotation.x = Math.PI / 2;
        petiole.castShadow = true;
        petiole.userData = { part: 'petiole', name: 'Πετίολος', description: 'Ο πετίολος είναι ο λεπτός σύνδεσμος μεταξύ του θώρακα και της κοιλιάς, που δίνει ευελιξία στο μυρμήγκι.' };
        thoraxGroup.add(petiole);

        const abdomenGroup = new THREE.Group();
        abdomenGroup.position.set(0,-0.02,-0.95);
        const abdomenGeo = new THREE.SphereGeometry(0.5,16,16);
        const abdomen = new THREE.Mesh(abdomenGeo, bodyMaterial);
        const abdomenWire = new THREE.Mesh(abdomenGeo, wireMaterial);
        abdomen.scale.set(0.9,0.95,1.4);
        abdomenWire.scale.set(0.9,0.95,1.4);
        abdomen.castShadow = true;
        abdomen.userData = { part: 'abdomen', name: 'Κοιλιά', description: 'Η κοιλιά περιέχει τα εντόσθια, το αναπαραγωγικό σύστημα και το κεντρί (στα είδη που έχουν). Συνδεδεμένα γονίδια: Gp-9, Si-OBP12, Si-OBP13' };
        abdomenGroup.add(abdomen, abdomenWire);
        thoraxGroup.add(abdomenGroup);

        antGroup.add(thoraxGroup);

        // LEGS
        const legSegments = [];
        const legPositions = [
            { x: 0.0, z: 0.25, side: 1 },
            { x: 0.0, z: 0.0, side: 1 },
            { x: 0.0, z: -0.25, side: 1 },
            { x: -0.0, z: 0.25, side: -1 },
            { x: -0.0, z: 0.0, side: -1 },
            { x: -0.0, z: -0.25, side: -1 }
        ];

        legPositions.forEach((pos, i) => {
            const legGroup = new THREE.Group();
            legGroup.position.set(pos.x, -0.15, pos.z);

            const coxa = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.035, 0.12, 8), legMaterial);
            coxa.rotation.z = pos.side * Math.PI / 3;
            coxa.position.set(pos.side * 0.14, -0.06, 0);
            coxa.castShadow = true;
            coxa.userData = { 
                part: 'coxa', 
                name: 'Κόξα', 
                description: 'Η κόξα είναι το πρώτο τμήμα του ποδιού, που συνδέεται απευθείας με τον θώρακα.',
                legIndex: i 
            };
            legGroup.add(coxa);

            const femurPivot = new THREE.Group();
            femurPivot.position.y = pos.side * 0.1;
            femurPivot.rotation.z = pos.side * Math.PI / 3.5;
            femurPivot.position.set(pos.side * 0.3, -0.18, 0);
            legGroup.add(femurPivot);
            const femur = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.025, 0.30, 10), legMaterial);
            femur.castShadow = true;
            femur.userData = { 
                part: 'femur', 
                name: 'Μηρός', 
                description: 'Ο μηρός είναι το δεύτερο και μεγαλύτερο τμήμα του ποδιού, παρέχει δύναμη για το περπάτημα.',
                legIndex: i 
            };
            femurPivot.add(femur);

            const tibiaPivot = new THREE.Group();
            tibiaPivot.position.y = -0.16;
            tibiaPivot.rotation.z = pos.side * -Math.PI / 2.5;
            femur.add(tibiaPivot);
            const tibia = new THREE.Mesh(new THREE.CylinderGeometry(0.022, 0.018, 0.25, 8), legMaterial);
            tibia.position.y = -0.125;
            tibia.castShadow = true;
            tibia.userData = { 
                part: 'tibia', 
                name: 'Κνήμη', 
                description: 'Η κνήμη είναι το τρίτο τμήμα του ποδιού, συνδέει τον μηρό με τον ταρσό.',
                legIndex: i 
            };
            tibiaPivot.add(tibia);

            const tarsusPivot = new THREE.Group();
            tarsusPivot.position.y = -0.12;
            tarsusPivot.rotation.z = pos.side * Math.PI / 8;
            tibia.add(tarsusPivot);
            const tarsus = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.01, 0.18, 6), legMaterial);
            tarsus.position.y = -0.09;
            tarsus.castShadow = true;
            tarsus.userData = { 
                part: 'tarsus', 
                name: 'Ταρσός', 
                description: 'Ο ταρσός είναι το τελευταίο τμήμα του ποδιού, αποτελείται από πολλά μικρά άρθρωμα κομμάτια.',
                legIndex: i 
            };
            tarsusPivot.add(tarsus);

            legSegments.push({ femurPivot, tibiaPivot, tarsusPivot, side: pos.side, index: i });
            thoraxGroup.add(legGroup);
        });

        scene.add(antGroup);
        antGroup.position.y = 0.5;
        camera.position.set(3, 2, 5);
        camera.lookAt(0, 0, 0);

        // Modal Elements
        const modalOverlay = document.getElementById('part-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalDescription = document.getElementById('modal-description');
        const modalClose = document.getElementById('modal-close');

        // Συνάρτηση εμφάνισης modal
        function showModal(title, description) {
            modalTitle.textContent = title;
            modalDescription.textContent = description;
            modalOverlay.style.display = 'flex';
        }

        // Κλείσιμο modal
        modalClose.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });

        // Κλείσιμο modal με κλικ έξω από το περιεχόμενο
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
            }
        });

        // Mouse interaction
        let isDragging = false, previousMouseX = 0, previousMouseY = 0;
        let rotationX = 0, rotationY = 0;

        // Raycaster για ανίχνευση κλικ σε αντικείμενα
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('mousedown', e => { 
            isDragging = true; 
            previousMouseX = e.clientX; 
            previousMouseY = e.clientY; 
        });
        
        document.addEventListener('mouseup', () => isDragging = false);
        
        document.addEventListener('mousemove', e => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                rotationY += deltaX * 0.01;
                rotationX += deltaY * 0.01;
                rotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, rotationX));
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });
        
        document.addEventListener('wheel', e => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(10, camera.position.z));
        });

        // Κλικ σε αντικείμενα
        document.addEventListener('click', (e) => {
            if (isDragging) {
                // Αν ο χρήστης έκανε drag, μην εμφανιστεί modal
                isDragging = false;
                return;
            }
            
            // Υπολογισμός θέσης του mouse σε κανονικοποιημένες συντεταγμένες
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Ορισμός του raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Υπολογισμός τομών
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                // Έλεγχος αν το αντικείμενο έχει userData
                if (clickedObject.userData && clickedObject.userData.name) {
                    // Εμφάνιση modal με τα δεδομένα του αντικειμένου
                    showModal(clickedObject.userData.name, clickedObject.userData.description);
                    
                    // Προσθήκη εφέ για το αντικείμενο που επιλέχθηκε
                    clickedObject.material.emissive.setHex(0x444444);
                    setTimeout(() => {
                        if (clickedObject.material.emissive) {
                            clickedObject.material.emissive.setHex(clickedObject.userData.part.includes('head') ? 0x3a0a00 : 
                                clickedObject.userData.part.includes('body') ? 0x4a1500 : 0x2a0800);
                        }
                    }, 300);
                }
            }
        });

        let time = 0, walkCycle = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            walkCycle += 0.08;

            if (!isDragging) antGroup.rotation.y += 0.003;
            else {
                antGroup.rotation.y = rotationY;
                antGroup.rotation.x = rotationX;
            }

            legSegments.forEach((leg, i) => {
                const phase = walkCycle + (i % 3) * (Math.PI * 2 / 3);
                const legLift = Math.max(0, Math.sin(phase) * 0.4);
                leg.tibiaPivot.rotation.z = leg.side * (-Math.PI / 2.5 + Math.cos(phase) * 0.4);
                leg.tarsusPivot.rotation.z = leg.side * (Math.PI / 8 + Math.sin(phase * 1.5) * 0.2);
            });

            antennaSegments.forEach((a, i) => {
                const p = time * 2 + i * Math.PI;
                a.seg1Pivot.rotation.x = Math.PI/8 + Math.sin(p)*0.15;
                a.seg2Pivot.rotation.x = Math.PI/10 + Math.cos(p*1.5)*0.2;
                a.scapePivot.rotation.z = a.side * (Math.PI/12 + Math.sin(p*0.7)*0.1);
            });

            antGroup.position.y = 0.5 + Math.sin(walkCycle*2)*0.08;
            if (!isDragging) antGroup.rotation.z = Math.sin(walkCycle)*0.05;

            const shimmer = Math.sin(time*2)*0.5 + 0.5;
            headMaterial.emissive.setHSL(0.05,1,0.05 + shimmer*0.1);
            bodyMaterial.emissive.setHSL(0.08,1,0.08 + shimmer*0.1);
            pointLight1.position.x = Math.cos(time*1.5)*8;
            pointLight1.position.z = Math.sin(time*1.5)*8;
            pointLight2.position.x = Math.sin(time)*8;
            pointLight2.position.z = Math.cos(time)*8;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
