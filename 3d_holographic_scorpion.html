<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Holographic Scorpion</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: #ff3333;
      font-family: 'Courier New', Courier, monospace;
      pointer-events: none;
      font-weight: bold;
      text-shadow: 0 0 10px #ff3333;
    }
  </style>
</head>
<body>
  <div id="info">ΣΚΟΡΠΙΟΣ</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(6, 4, 6);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- MATERIALS ---
    const COLOR = 0xff3333;

    const solidMat = new THREE.MeshBasicMaterial({
      color: COLOR,
      transparent: true,
      opacity: 0.15,
      side: THREE.DoubleSide,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const wireMat = new THREE.MeshBasicMaterial({
      color: COLOR,
      wireframe: true,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending
    });

    const jointMat = new THREE.MeshBasicMaterial({
      color: 0xffaaaa,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });

    // --- HELPER FUNCTIONS ---
    function createPart(geometry, material = solidMat) {
      const group = new THREE.Group();
      const mesh = new THREE.Mesh(geometry, material);
      const wire = new THREE.Mesh(geometry, wireMat);
      group.add(mesh);
      group.add(wire);
      return group;
    }

    function createJoint(size) {
      const geo = new THREE.SphereGeometry(size, 8, 8);
      return createPart(geo, jointMat);
    }

    // --- BUILD SCORPION ---
    const scorpion = new THREE.Group();
    scene.add(scorpion);

    // 1. MAIN BODY
    const bodyGeo = new THREE.SphereGeometry(1, 12, 12);
    const body = createPart(bodyGeo);
    body.scale.set(1, 0.5, 1.5);
    scorpion.add(body);

    // 2. TAIL
    let currentParent = scorpion;
    let lastPos = new THREE.Vector3(0, 0.2, 1.3);

    const tailSegments = 5;
    const tailLength = 0.8;
    const tailPivots = [];

    for (let i = 0; i < tailSegments; i++) {
      const pivot = new THREE.Group();

      if (i === 0) pivot.position.copy(lastPos);
      else pivot.position.set(0, tailLength, 0);

      currentParent.add(pivot);
      tailPivots.push(pivot);

      const joint = createJoint(0.35 - (i * 0.05));
      pivot.add(joint);

      const segGeo = new THREE.CylinderGeometry(
        0.3 - (i * 0.05),
        0.35 - (i * 0.05),
        tailLength,
        8
      );
      segGeo.translate(0, tailLength / 2, 0);

      const segment = createPart(segGeo);
      pivot.add(segment);

      currentParent = pivot;
    }

    // 3. STINGER
    const stingerPivot = new THREE.Group();
    stingerPivot.position.set(0, tailLength, 0);
    currentParent.add(stingerPivot);

    const bulbGeo = new THREE.SphereGeometry(0.3, 8, 8);
    const bulb = createPart(bulbGeo);
    stingerPivot.add(bulb);

    const needleGeo = new THREE.ConeGeometry(0.1, 0.6, 8);
    needleGeo.translate(0, 0.3, 0);
    needleGeo.rotateX(-Math.PI / 2);

    const needle = createPart(needleGeo);
    needle.position.set(0, 0, -0.2);
    stingerPivot.add(needle);

    // 4. LEGS
    function buildLeg(xDir, zOffset) {
      const legSystem = new THREE.Group();
      legSystem.position.set(xDir * 0.5, -0.1, zOffset);

      const fanAngle = zOffset * 0.5;
      legSystem.rotation.y = (xDir === 1 ? -fanAngle : fanAngle);

      const hip = createJoint(0.15);
      legSystem.add(hip);

      const thighPivot = new THREE.Group();
      thighPivot.rotation.z = xDir === 1 ? -0.5 : 0.5;
      legSystem.add(thighPivot);

      const thighGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.8, 6);
      thighGeo.translate(0, 0.4, 0);

      const thighM = createPart(thighGeo);
      thighM.rotation.z = xDir === 1 ? -0.8 : 0.8;
      thighPivot.add(thighM);

      const kneePivot = new THREE.Group();
      const rotZ = xDir === 1 ? -0.8 : 0.8;
      kneePivot.position.set(-Math.sin(rotZ) * 0.8, Math.cos(rotZ) * 0.8, 0);
      thighPivot.add(kneePivot);

      kneePivot.add(createJoint(0.12));

      const shinPivot = new THREE.Group();
      shinPivot.rotation.z = xDir === 1 ? 1.0 : -1.0;
      kneePivot.add(shinPivot);

      const shinGeo = new THREE.CylinderGeometry(0.08, 0.02, 1.0, 8);
      shinGeo.translate(0, -0.5, 0);

      const shinM = createPart(shinGeo);
      shinPivot.add(shinM);

      return legSystem;
    }

    for (let i = 0; i < 4; i++) {
      const z = 0.5 - (i * 0.5);
      scorpion.add(buildLeg(1, z));
      scorpion.add(buildLeg(-1, z));
    }

    // 5. CLAWS
    function buildClaw(isLeft) {
      const xDir = isLeft ? 1 : -1;
      const root = new THREE.Group();
      root.position.set(xDir * 0.4, 0, -1.0);

      root.add(createJoint(0.2));

      const armPivot = new THREE.Group();
      armPivot.rotation.y = isLeft ? 1.0 : -1.0;
      root.add(armPivot);

      const armGeo = new THREE.CylinderGeometry(0.15, 0.1, 1.2, 8);
      armGeo.translate(0, 0.6, 0);
      armGeo.rotateZ(isLeft ? -1.5 : 1.5);

      const arm = createPart(armGeo);
      armPivot.add(arm);

      const wrist = new THREE.Group();
      wrist.position.set(isLeft ? 1.2 : -1.2, 0, 0);
      armPivot.add(wrist);
      wrist.add(createJoint(0.25));

      const clawBodyGeo = new THREE.SphereGeometry(0.3, 8, 8);
      clawBodyGeo.scale(1, 0.5, 1.5);
      const clawBody = createPart(clawBodyGeo);
      wrist.add(clawBody);

      const fingerGeo = new THREE.ConeGeometry(0.08, 0.6, 8);
      fingerGeo.rotateX(-Math.PI / 2);

      const f1 = createPart(fingerGeo);
      f1.position.set(isLeft ? 0.15 : -0.15, 0, -0.4);
      clawBody.add(f1);

      const f2 = createPart(fingerGeo);
      f2.position.set(isLeft ? -0.15 : 0.15, 0, -0.4);
      f2.rotation.y = isLeft ? -0.5 : 0.5;
      clawBody.add(f2);

      return root;
    }

    scorpion.add(buildClaw(true));
    scorpion.add(buildClaw(false));

    // --- GRID FLOOR ---
    const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x111111);
    gridHelper.position.y = -1;
    scene.add(gridHelper);

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // FLOAT ONLY (don’t overwrite rotation every frame)
      scorpion.position.y = 1.0 + Math.sin(t) * 0.1;

      // TAIL ANIMATION
      tailPivots.forEach((pivot, i) => {
        const baseAngle = -0.3;
        pivot.rotation.x = baseAngle + Math.sin(t * 1.5 + i) * 0.05;
      });

      stingerPivot.rotation.x = -0.5 + Math.sin(t * 3) * 0.1;

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
